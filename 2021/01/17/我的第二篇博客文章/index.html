

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/clover2.png">
  <link rel="icon" type="image/png" href="/img/clover2.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="个人博客, 程序员, web技术, 生活感悟, 马克思主义哲学, 童年回忆, 生活小确幸">
  <meta name="author" content="Jerry Bian">
  <meta name="keywords" content="">
  <title>我的第二篇博客文章 - Jerry Bian&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h2","placement":"right","visible":"hover","icon":"🍀"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Jerry Bian's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post_page_banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.4)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="我的第二篇博客文章">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Jerry Bian
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-17 00:00" pubdate>
        2021年1月17日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      176
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">我的第二篇博客文章</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：4 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Web前端自测题答案参考"><a href="#Web前端自测题答案参考" class="headerlink" title="Web前端自测题答案参考"></a>Web前端自测题答案参考</h1><h1 id="1-HTML，-HTTP，web综合问题"><a href="#1-HTML，-HTTP，web综合问题" class="headerlink" title="1.HTML， HTTP，web综合问题"></a>1.HTML， HTTP，web综合问题</h1><h3 id="1、前端需要注意哪些SEO"><a href="#1、前端需要注意哪些SEO" class="headerlink" title="1、前端需要注意哪些SEO"></a>1、前端需要注意哪些SEO</h3><ul>
<li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li>
<li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>
<li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li>
<li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li>
<li>非装饰性图片必须加<code>alt</code></li>
<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
</ul>
<h3 id="2、-lt-img-gt-的title和alt有什么区别"><a href="#2、-lt-img-gt-的title和alt有什么区别" class="headerlink" title="2、&lt;img&gt;的title和alt有什么区别"></a>2、<code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3><ul>
<li>==鼠标滑动==到元素上的时候显示</li>
<li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于**==图片无法加载==<strong>时显示，</strong>==搜索引擎==**会重点分析。</li>
</ul>
<h3 id="3、HTTP的几种请求方法用途"><a href="#3、HTTP的几种请求方法用途" class="headerlink" title="3、HTTP的几种请求方法用途"></a>3、HTTP的几种请求方法用途</h3><ul>
<li>1、<code>GET</code>方法<ul>
<li>发送一个请求来==取得==服务器上的某一资源</li>
</ul>
</li>
<li>2、<code>POST</code>方法<ul>
<li>向<code>URL</code>指定的资源==提交数据==或==附加==新的数据</li>
</ul>
</li>
<li>3、<code>PUT</code>方法<ul>
<li>跟<code>POST</code>方法很像，也是向服务器提交数据。但是，它们之间有不同。PUT==指定==了资源在服务器上的==位置==，而<code>POST</code>没有</li>
</ul>
</li>
<li>4、<code>HEAD</code>方法<ul>
<li>只请求页面的==首部==</li>
</ul>
</li>
<li>5、<code>DELETE</code>方法<ul>
<li>==删除==服务器上的某资源</li>
</ul>
</li>
<li>6、<code>OPTIONS</code>方法<ul>
<li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li>
</ul>
</li>
<li>7、<code>TRACE</code>方法<ul>
<li><code>TRACE</code>方法被用于==激发==一个远程的，应用层的请求==消息回路==</li>
</ul>
</li>
<li>8、<code>CONNECT</code>方法<ul>
<li>把请求连接转换到透明的<code>TCP/IP</code>通道</li>
</ul>
</li>
</ul>
<h3 id="4、从浏览器地址栏输入url到显示页面的步骤"><a href="#4、从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="4、从浏览器地址栏输入url到显示页面的步骤"></a>4、从浏览器地址栏输入url到显示页面的步骤</h3><ul>
<li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li>
<li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ul>
<h3 id="5、如何进行网站性能优化"><a href="#5、如何进行网站性能优化" class="headerlink" title="5、如何进行网站性能优化"></a>5、如何进行网站性能优化</h3><ul>
<li><code>content</code>方面<ol>
<li>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li>
<li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li>
<li>减少<code>DOM</code>元素数量</li>
</ol>
</li>
<li><code>Server</code>方面<ol>
<li>使用<code>CDN</code></li>
<li>配置<code>ETag</code></li>
<li>对组件使用<code>Gzip</code>压缩</li>
</ol>
</li>
<li><code>Cookie</code>方面<ol>
<li>减小<code>cookie</code>大小</li>
</ol>
</li>
<li><code>css</code>方面<ol>
<li>将样式表放到页面顶部</li>
<li>不使用<code>CSS</code>表达式</li>
<li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li>
</ol>
</li>
<li><code>Javascript</code>方面<ol>
<li>将脚本放到页面底部</li>
<li>将<code>javascript</code>和<code>css</code>从外部引入</li>
<li>压缩<code>javascript</code>和<code>css</code></li>
<li>删除不需要的脚本</li>
<li>减少<code>DOM</code>访问</li>
</ol>
</li>
<li>图片方面<ol>
<li>优化图片：根据实际颜色需要选择色深、压缩</li>
<li>优化<code>css</code>精灵</li>
<li>不要在<code>HTML</code>中拉伸图片</li>
</ol>
</li>
</ul>
<h3 id="6、HTTP状态码及其含义"><a href="#6、HTTP状态码及其含义" class="headerlink" title="6、HTTP状态码及其含义"></a>6、HTTP状态码及其含义</h3><ul>
<li><pre><code>1XX
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  ：信息状态码<br><br>  - `100 <span class="hljs-keyword">Continue</span>` ==继续==，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息<br><br>- ```<br>  <span class="hljs-number">2</span>XX<br></code></pre></td></tr></table></figure>
：成功状态码

- `200 OK` ==正常==返回信息
- `201 Created` 请求成功并且服务器==创建==了新的资源
- `202 Accepted` 服务器已接受请求，但尚==未处理==</code></pre>
</li>
<li><pre><code>3XX
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  ：重定向<br><br>  - `301 Moved Permanently` 请求的网页已==永久移动==到新位置。<br>  - `302 Found` ==临时性==重定向。<br>  - `303 See Other` 临时性重定向，且==总是==使用 `GET` 请求新的 `URI`。<br>  - `304 <span class="hljs-literal">Not</span> Modified` 自从上次请求后，请求的网页==未修改==过。<br><br>- ```<br>  <span class="hljs-number">4</span>XX<br></code></pre></td></tr></table></figure>
：客户端错误

- `400 Bad Request` 服务器==无法理解==请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
- `401 Unauthorized` 请求==未授权==。
- `403 Forbidden` ==禁止==访问。
- `404 Not Found` ==找不到==如何与 `URI` 相匹配的资源。</code></pre>
</li>
<li><pre><code>5XX
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  服务器错误<br><br>  - `500 Internal Server Error` 最==常见==的服务器端错误。<br>  - `503 Service Unavailable` 服务器端==暂时无法处理==请求（可能是过载或维护）。<br><br>### <span class="hljs-number">7</span>、语义化的理解<br><br>- 用==合适==的标签。<br>- `html`语义化就是让页面的内容==结构化==，==便于==对浏览器、搜索引擎==解析==；<br>- ==搜索引擎==的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 `SEO`。<br>- 使==阅读==源代码的人对网站更容易将网站分块，便于阅读维护理解<br>- 在没有样式`CSS`情况下也以一种文档格式显示，并且是==容易阅读==的。<br><br>### <span class="hljs-number">8</span>、介绍一下你对浏览器内核的理解？<br><br>- 主要分成两部分：==渲染引擎==(`layout engineer`或`Rendering Engine`)和==`JS`引擎==<br>- 渲染引擎：&lt;u&gt;负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。&lt;/u&gt;浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核<br>- `JS`引擎则：&lt;u&gt;解析和执行`javascript`来实现网页的动态效果&lt;/u&gt;<br>- 最开始渲染引擎和`JS`引擎并没有==区分==的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎<br><br>### <span class="hljs-number">9</span>、html5有哪些新特性、移除了那些元素？<br><br>- `HTML5` 现在已经不是 `SGML` 的子集，主要是关于==媒体==，==存储==，==语义化==，==新控件==，==新技术==等功能的增加<br>  - 绘画 `canvas`<br>  - 用于媒介回放的 `video` 和 `audio` 元素<br>  - 本地离线存储 `localStorage` 长期存储数据，浏览器关闭后数据不丢失<br>  - `sessionStorage` 的数据在浏览器关闭后自动删除<br>  - 语义化更好的内容元素，比如`article`、`footer`、`header`、`nav`、`section`<br>  - 表单控件，`calendar`、`date`、`time`、`email`、`url`、`search`<br>  - 新的技术`webworker`, `websocket`, `Geolocation`<br>- 移除的元素：<br>  - ==纯表现==的元素：`basefont`，`big`，`center`，`font`, `s`，`strike`，`tt`，`u`。<br>  - 对可用性==产生负面影响==的元素：`frame`，`frameset`，`noframes`<br>- 支持`HTML5`新标签：<br>  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签<br>  - 可以利用这一特性让这些浏览器支`持HTML5`新标签<br>  - 浏览器支持新标签后，还需要添加标签默认的样式<br>- 当然也可以直接使用成熟的框架、比如`html5shim`<br><br>### <span class="hljs-number">10</span>、`HTML5`的离线储存怎么使用，工作原理能不能解释一下？<br><br>- &lt;u&gt;在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件&lt;/u&gt;<br>- 原理：`HTML5`的离线存储是基于一个新建的`.appcache`文件的==缓存机制==(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像`cookie`一样被存储了下来。&lt;u&gt;之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示&lt;/u&gt;<br>- 如何使用：<br>  - ==页面头部==像下面一样加入一个`manifest`的属性；<br>  - 在`cache.manifest`文件的==编写==离线存储的资源<br>  - 在==离线状态==时，操作`window.applicationCache`进行需求实现<br><br>```html<br>CACHE MANIFEST<br><span class="hljs-meta">#v0.11</span><br><span class="hljs-title">CACHE:</span><br>js/app.js<br>css/style.css<br><span class="hljs-title">NETWORK:</span><br>resourse/logo.png<br><span class="hljs-title">FALLBACK:</span><br>/ /offline.html<br></code></pre></td></tr></table></figure>
### 11、浏览器是怎么对`HTML5`的离线储存资源进行管理和加载的呢</code></pre>
</li>
<li><p>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是==第一次==访问<code>app</code>，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行==离线存储==。如果已经访问过<code>app</code>并且资源已经离线存储了，那么==浏览器==就会==使用====离线的资源==加载页面，然后浏览器会==对比新的==<code>manifest</code>文件与旧的<code>manifes</code>t文件，如果文件没有发生改变，就==不做任何操作==，如果文件改变了，那么就会==重新==下载文件中的资源并进行离线存储。</p>
</li>
<li><p>离线的情况下，浏览器就直接使用离线存储的资源。</p>
</li>
</ul>
<h3 id="12、请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#12、请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="12、请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>12、请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h3><ul>
<li><code>cookie</code>是网站为了标示用户身份而储存在用户本地==终端==（Client Side）上的数据（通常经过加密）</li>
<li>cookie==数据==始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间==来回传递==</li>
<li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在==本地保存==</li>
<li>存储==大小==：<ul>
<li><code>cookie</code>数据大小不能超过4k</li>
<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
</ul>
</li>
<li>有效==时间==：<ul>
<li><code>localStorage</code> 存储==持久==数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li><code>sessionStorage</code> 数据在当前浏览器==窗口关闭==后自动删除</li>
<li><code>cookie</code> 设置的<code>cookie</code>==过期==时间==之前==一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
</ul>
<h3 id="13、iframe有那些缺点？"><a href="#13、iframe有那些缺点？" class="headerlink" title="13、iframe有那些缺点？"></a>13、iframe有那些缺点？</h3><ul>
<li><code>iframe</code>会==阻塞==主页面的<code>Onload</code>事件</li>
<li>==搜索引擎==的检索程序无法解读这种页面，不利于<code>SEO</code></li>
<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的==并行加载==</li>
<li>使用<code>iframe</code>之前需要考虑这两个缺点。 如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>
</ul>
<h3 id="14、WEB标准以及W3C标准是什么"><a href="#14、WEB标准以及W3C标准是什么" class="headerlink" title="14、WEB标准以及W3C标准是什么?"></a>14、WEB标准以及W3C标准是什么?</h3><ul>
<li>标签闭合、小写、嵌套。</li>
<li>使用外链<code>css</code>和<code>js</code>。</li>
<li>结构样式行为相分离</li>
</ul>
<h3 id="15、xhtml和html有什么区别"><a href="#15、xhtml和html有什么区别" class="headerlink" title="15、xhtml和html有什么区别?"></a>15、xhtml和html有什么区别?</h3><ul>
<li>==兼容==<ul>
<li>主要是<code>XHTML</code>可兼容各大<u>浏览器、手机</u>，并且浏览器也能快速<u>正确地编译</u>网页</li>
</ul>
</li>
<li>==严谨==<ul>
<li><code>XHTML</code> 元素必须被正确地<u>嵌套，闭合，区分大小写</u></li>
</ul>
</li>
</ul>
<h3 id="16、Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#16、Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><ul>
<li><strong>作用</strong><ul>
<li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li>
</ul>
</li>
<li><strong>区分</strong><ul>
<li>HTML5 不区分</li>
<li>文档包含DOCTYPE ，严格模式。</li>
<li>DOCTYPE <u><strong>不存在</strong></u>或<u><strong>形式不正确</strong></u>会导致混杂模式。</li>
<li>有 URI 的过渡 DTD —严格模式；否则为混杂模式</li>
</ul>
</li>
<li><strong>意义</strong><ul>
<li>严格模式与混杂模式存在的意义与其==来源==密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</li>
</ul>
</li>
</ul>
<h3 id="17、行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？"><a href="#17、行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？" class="headerlink" title="17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？"></a>17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3><ul>
<li>==行级==元素不可以设置宽高，不独占一行：<code>a span em strong del </code></li>
<li>==块级==元素可以设置宽高，独占一行：<code>div ul ol li dd dl dt h1 h2 h3 h4…p</code></li>
<li>空元素(单标签)：<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>
</ul>
<h3 id="18、HTML全局属性-global-attribute-有哪些"><a href="#18、HTML全局属性-global-attribute-有哪些" class="headerlink" title="18、HTML全局属性(global attribute)有哪些"></a>18、HTML全局属性(global attribute)有哪些</h3><ul>
<li><code>lang</code>: 元素内容的的语言</li>
<li><code>title</code>: 元素相关的建议信息</li>
<li><code>style</code>: 行内<code>css</code>样式</li>
<li><code>class</code>:为元素设置类标识</li>
<li><code>id</code>: 元素<code>id</code>，文档内唯一</li>
<li><code>data-*</code>: 为元素增加自定义属性</li>
<li><code>draggable</code>: 设置元素是否可拖拽</li>
</ul>
<h3 id="18、link和-import区别"><a href="#18、link和-import区别" class="headerlink" title="18、link和@import区别"></a>18、link和@import区别</h3><ul>
<li>html被加载的时，<code>link</code>会==同时==被加载；而<code>@imort</code>等到页面被==加载完==再加载</li>
<li>link是XHTML标签，无==兼容==问题，import<code>只在</code>IE5以上才能识别</li>
<li>link==权重==高于@import</li>
</ul>
<h1 id="2-CSS部分"><a href="#2-CSS部分" class="headerlink" title="2.CSS部分"></a>2.CSS部分</h1><h3 id="1、css-sprite是什么-有什么优缺点"><a href="#1、css-sprite是什么-有什么优缺点" class="headerlink" title="1、css sprite是什么,有什么优缺点"></a>1、css sprite是什么,有什么优缺点</h3><ul>
<li>概念：将多个小图片拼接到一个图片中。通过<code>background-position</code>和元素尺寸调节需要显示的背景图案。</li>
<li>优点：<ul>
<li>减少<code>HTTP</code>请求数，极大地提高页面加载速度</li>
<li>增加图片信息重复度，提高压缩比，减少图片大小</li>
<li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li>
</ul>
</li>
<li>缺点：<ul>
<li>图片合并麻烦</li>
<li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li>
</ul>
</li>
</ul>
<h3 id="2、display-none-与visibility-hidden-的区别"><a href="#2、display-none-与visibility-hidden-的区别" class="headerlink" title="2、display: none;与visibility: hidden;的区别"></a>2、<code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3><ul>
<li>联系：它们都能让元素==不可见==</li>
<li>区别：<ul>
<li><strong>样式</strong><ul>
<li><code>display:none</code>元素从==DOM树中消失==；</li>
<li><code>visibility: hidden</code>元素存在于DOM树，渲染时元占据空间，只是==内容不可见==</li>
</ul>
</li>
<li><strong>文档</strong><ul>
<li>修改常规流中元素的<code>display</code>通常会造成==文档重排==。修改<code>visibility</code>属性只会造成本==元素重绘==。</li>
</ul>
</li>
<li><strong>读屏器</strong><ul>
<li><strong>不</strong>读取<code>display: none</code>;元素内容；</li>
<li>读取<code>visibility: hidden;</code>元素内容</li>
</ul>
</li>
<li><strong>继承</strong><ul>
<li><code>display: none</code>;==非继承==属性，元素从渲染树消失造成子孙节点也**==消失==**，通过==修改==子孙节点属性==无法==显示</li>
<li><code>；visibility: hidden;</code>是==继承==属性，子孙节点==消失==由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>==可以==让子孙节点显式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、link与-import的区别"><a href="#3、link与-import的区别" class="headerlink" title="3、link与@import的区别"></a>3、<code>link</code>与<code>@import</code>的区别</h3><ol>
<li><code>link</code>是<code>HTML</code>==方式==， <code>@import</code>是CSS方式</li>
<li><code>link</code>最大限度支持==并行==下载，<code>@import</code>过多嵌套导致==串行==下载，出现<code>FOUC</code></li>
<li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>==指定候选样式==</li>
<li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li>
<li><code>@import</code>必须在样式规则==之前==，可以在css文件中==引用其他文件==</li>
<li>总体来说：<code>link</code>==优于==<code>@import</code></li>
</ol>
<h3 id="4、什么是FOUC-如何避免"><a href="#4、什么是FOUC-如何避免" class="headerlink" title="4、什么是FOUC?如何避免"></a>4、什么是FOUC?如何避免</h3><ul>
<li><code>Flash Of Unstyled Content</code>：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成==页面闪烁==。</li>
<li><strong>==解决==方法</strong>：把样式表放到文档的<code>head</code></li>
</ul>
<h3 id="5、如何创建块级格式化上下文-block-formatting-context-BFC有什么用"><a href="#5、如何创建块级格式化上下文-block-formatting-context-BFC有什么用" class="headerlink" title="5、如何创建块级格式化上下文(block formatting context),BFC有什么用"></a>5、如何创建块级格式化上下文(block formatting context),BFC有什么用</h3><ul>
<li>创建规则：<ul>
<li>根元素</li>
<li>浮动元素（<code>float</code>不是<code>none</code>）</li>
<li>绝对定位元素（<code>position</code>取值为<code>absolute</code>或<code>fixed</code>）</li>
<li><code>display</code>取值为<code>inline-block</code>,<code>table-cell</code>, <code>table-caption</code>,<code>flex</code>, <code>inline-flex</code>之一的元素</li>
<li><code>overflow</code>不是<code>visible</code>的元素</li>
</ul>
</li>
<li>作用：<ul>
<li>可以包含浮动元素</li>
<li>不被浮动元素覆盖</li>
<li>阻止父子元素的<code>margin</code>折叠</li>
</ul>
</li>
</ul>
<h3 id="6、float-display-position的关系"><a href="#6、float-display-position的关系" class="headerlink" title="6、float,display,position的关系"></a>6、float,display,position的关系</h3><ul>
<li>float: left / right; 可以自动排列自动折行, 但需要clear来配合==清除浮动==</li>
<li>display: inline-block; 有些时候可以==替代float==实现相同的效果</li>
<li>position: absolute / relative; 要配合top,left等==定位==</li>
<li>文档流<ul>
<li>float也会导致元素==脱离==文档流，但还在文档或容器中==占据位置==，把文档流和其它float元素向左或向右挤，并可能导致换行。<u>图片的文字环绕布局效果就是float。</u></li>
<li>display的inline-block==不脱离==文档流，将block元素当作大型字符嵌入文档流内，<u>类似于img或者input默认效果。</u></li>
<li>position: absolute会导致元素==脱离==文档流，被定位的元素等于在文档中不占据任何位置，在另一个层呈现，可以设置z-index。PS的图层效果就是position: absolute。</li>
</ul>
</li>
</ul>
<h3 id="7、清除浮动的几种方式，各自的优缺点"><a href="#7、清除浮动的几种方式，各自的优缺点" class="headerlink" title="7、清除浮动的几种方式，各自的优缺点"></a>7、清除浮动的几种方式，各自的优缺点</h3><ul>
<li>用<code>afert</code>==伪元素==清除浮动(<code>IE8</code>以上和非<code>IE</code>浏览器才支持，目前：大型网站都有使用</li>
<li>使用==空标签==清除浮动<code>clear:both</code>（缺点，增加无意义的标签）</li>
<li>使用<code>overflow:auto</code>（使用<code>zoom:1</code>用于兼容<code>IE</code>，缺点：内部宽高超过父级<code>div</code>时，会出现滚动条）</li>
</ul>
<h3 id="8、为什么要初始化CSS样式"><a href="#8、为什么要初始化CSS样式" class="headerlink" title="8、为什么要初始化CSS样式?"></a>8、为什么要初始化CSS样式?</h3><ul>
<li>因为==浏览器的兼容==问题，不同浏览器对有些标签的默认值是不同的，如果没对<code>CSS</code>初始化往往会出现浏览器之间的页面显示差异。</li>
<li>当然，初始化样式会对<code>SEO</code>有==一定的影响==，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</li>
</ul>
<h3 id="9、css3有哪些新特性"><a href="#9、css3有哪些新特性" class="headerlink" title="9、css3有哪些新特性"></a>9、css3有哪些新特性</h3><ul>
<li>新增各种<code>css</code>选择器</li>
<li>圆角 <code>border-radius</code></li>
<li>文字特效<code>text-shadow</code></li>
<li>线性渐变</li>
<li>旋转<code>transform</code></li>
<li>多列布局</li>
<li>阴影和反射</li>
</ul>
<p><strong>CSS3新增伪类有那些？</strong></p>
<ul>
<li><code>:first-of-type </code>选择器匹配属于其父元素的<strong>特定类型</strong>的==首个==子元素的每个元素。</li>
<li><code>:last-of-type</code> 选择器匹配属于其父元素的<strong>特定类型</strong>的==最后==一个子元素的每个元素。</li>
<li><code>:only-of-type</code> 选择器匹配属于其父元素的<strong>特定类型</strong>的==唯一==子元素的每个元素。</li>
<li><code>:only-child</code> 选择器匹配属于其父元素的==唯一==子元素。</li>
<li><code>:nth-child(2)</code> 选择器匹配属于其父元素的==第 N 个==子元素，不论元素的类型。</li>
<li><code>:before :after</code> 在==元素之前/后==添加内容,也可以用来做清除浮动。</li>
<li><code>:enabled :disabled</code> 控制表单控件的==可用/禁用==状态。</li>
<li><code>:checked</code>选择器匹配每个==选中==的输入元素（仅适用于单选按钮或复选框）。</li>
</ul>
<h3 id="10、display有哪些值？说明他们的作用"><a href="#10、display有哪些值？说明他们的作用" class="headerlink" title="10、display有哪些值？说明他们的作用"></a>10、display有哪些值？说明他们的作用</h3><table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">此元素不会被显示。</td>
</tr>
<tr>
<td align="left">block</td>
<td align="left">此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td align="left">inline</td>
<td align="left">默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td align="left">inline-block</td>
<td align="left">行内块元素。（CSS2.1 新增的值）</td>
</tr>
</tbody></table>
<h3 id="11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><ul>
<li>有==两种==， <code>IE盒子</code>、<code>W3C盒子</code>；</li>
<li>盒模型： 内容(<code>content</code>)、填充(<code>padding</code>)、边界(<code>margin</code>)、 边框(<code>border</code>)；</li>
<li>区 别：<strong>低版本IE浏览器==内容==部分的width和height是把内边距（==padding==）和边框宽度（==border==）也算进去</strong></li>
</ul>
<h3 id="12、CSS优先级算法如何计算？"><a href="#12、CSS优先级算法如何计算？" class="headerlink" title="12、CSS优先级算法如何计算？"></a>12、CSS优先级算法如何计算？</h3><ul>
<li>优先级为:<ul>
<li>！important</li>
<li>行间样式</li>
<li>id</li>
<li>class|属性｜伪类</li>
<li>标签选择器｜伪元素</li>
<li>通配符</li>
</ul>
</li>
</ul>
<h3 id="13、对BFC规范的理解？"><a href="#13、对BFC规范的理解？" class="headerlink" title="13、对BFC规范的理解？"></a>13、对BFC规范的理解？</h3><ul>
<li>它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用</li>
</ul>
<h3 id="14、谈谈浮动和清除浮动"><a href="#14、谈谈浮动和清除浮动" class="headerlink" title="14、谈谈浮动和清除浮动"></a>14、谈谈浮动和清除浮动</h3><ul>
<li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li>
</ul>
<h3 id="15、position的值，-relative和absolute定位原点是"><a href="#15、position的值，-relative和absolute定位原点是" class="headerlink" title="15、position的值， relative和absolute定位原点是"></a>15、position的值， relative和absolute定位原点是</h3><ul>
<li><code>relative</code>：生成==相对==定位的元素，相对于其==自己==的位置进行定位</li>
<li><code>absolute</code>：生成==绝对==定位的元素，相对于最近的==有定位的父级==进行定位</li>
<li><code>fixed</code>：生成==绝对定位==的元素，相对于<strong>浏览器窗口</strong>进行定位</li>
<li><code>static</code> ==默认值==。没有定位，元素出现在正常的流中</li>
<li><code>inherit</code> 规定从父元素==继承== <code>position</code> 属性的值</li>
</ul>
<h3 id="16、display-inline-block-什么时候不会显示间隙？-携程"><a href="#16、display-inline-block-什么时候不会显示间隙？-携程" class="headerlink" title="16、display:inline-block 什么时候不会显示间隙？(携程)"></a>16、display:inline-block 什么时候不会显示间隙？(携程)</h3><ul>
<li>移除空白节点</li>
<li>使用<code>margin</code>负值</li>
<li>父级<code>font-size:0</code></li>
</ul>
<h3 id="17、PNG-GIF-JPG的区别及如何选"><a href="#17、PNG-GIF-JPG的区别及如何选" class="headerlink" title="17、PNG,GIF,JPG的区别及如何选"></a>17、PNG,GIF,JPG的区别及如何选</h3><blockquote>
<h2 id="GIF："><a href="#GIF：" class="headerlink" title="GIF："></a>GIF：</h2><p>1：256色</p>
<p>2： ==无损==，编辑 保存时候，不会损失。</p>
<p>3：支持简单==动画==。</p>
<p>4：支持boolean透明，也就是要么完全透明，要么不透明</p>
<h2 id="JPEG："><a href="#JPEG：" class="headerlink" title="JPEG："></a>JPEG：</h2><p>1：millions of colors</p>
<p>2： ==有损==压缩， 意味着每次编辑都会失去质量。</p>
<p>3：不支持透明。</p>
<p>4：适合照片，实际上很多相机使用的都是这个格式。</p>
<h2 id="PNG："><a href="#PNG：" class="headerlink" title="PNG："></a>PNG：</h2><p>1：无损，其实PNG有好几种格式的，一般分为两类：PNG8和truecolor PNGs；</p>
<p>与GIF相比：</p>
<ul>
<li>它通常会产生较小的文件大小。</li>
<li>它支持阿尔法（变量）透明度。</li>
<li>无动画支持</li>
</ul>
<p>与JPEG相比：</p>
<ul>
<li>文件更大</li>
<li>无损</li>
<li>因此可以作为JPEG图片中间编辑的中转格式。</li>
</ul>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>JPEG适合==照片==</p>
<p>GIF适合==动画==</p>
<p>PNG8适合其他任何种类——==图表，按钮，背景==等等。</p>
</blockquote>
<h1 id="3-JavaScript"><a href="#3-JavaScript" class="headerlink" title="3.JavaScript"></a>3.JavaScript</h1><h3 id="1、闭包"><a href="#1、闭包" class="headerlink" title="1、闭包"></a>1、闭包</h3><ul>
<li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li>
<li>闭包的特性：<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
</li>
</ul>
<p><strong>说说你对闭包的理解</strong></p>
<ul>
<li>使用闭包主要是为了设计私有的方法和变量。闭包的==优点==是可以<u>避免全局变量的污染</u>，==缺点==是闭包会<u>常驻内存，会增大内存使用量，使用不当很容易造成内存泄露</u>。在js中，函数即闭包，只有函数才会产生作用域的概念</li>
</ul>
<h3 id="2、说说你对作用域链的理解"><a href="#2、说说你对作用域链的理解" class="headerlink" title="2、说说你对作用域链的理解"></a>2、说说你对作用域链的理解</h3><ul>
<li>作用域链的==规则==是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能==向上访问==，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li>
<li>简单的说，作用域就是变量与函数的可访问==范围==，即作用域控制着变量与函数的<strong>可见性</strong>和<strong>生命周期</strong></li>
</ul>
<h3 id="3、JavaScript原型，原型链-有什么特点？"><a href="#3、JavaScript原型，原型链-有什么特点？" class="headerlink" title="3、JavaScript原型，原型链 ? 有什么特点？"></a>3、JavaScript原型，原型链 ? 有什么特点？</h3><ul>
<li><p>每个对象都会在其内部==初始化==一个属性，就是<code>prototype</code>(原型)，当我们访问一个对象的属性时</p>
<p>如果这个对象内部==不存在==这个属性，那么他就会去<code>prototype</code>里找这个属性，这<code>个prototype</code>又会有==自己的==<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</p>
</li>
<li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p>
</li>
<li><p>特点：<code>JavaScript</code>对象是通过==引用==来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</p>
</li>
<li><p>当我们需要一个属性的时，<code>Javascript</code>引擎会先看当前对象中是否有这个==属性==， 如果没有的</p>
<p>就会查找他的==Prototype对象==是否有这个属性，如此递推下去，一直检索到 ==Object内建对象==</p>
</li>
</ul>
<h3 id="4、请解释什么是事件代理"><a href="#4、请解释什么是事件代理" class="headerlink" title="4、请解释什么是事件代理"></a>4、请解释什么是事件代理</h3><ul>
<li><p><strong>概念</strong>：事件代理（<code>Event Delegation</code>），又称之为<strong>事件委托</strong>。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给==父元素==，让父元素担当事件监听的职务。</p>
</li>
<li><p><strong>原理：</strong>事件代理的==原理==是DOM元素的事件冒泡。</p>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>提高性能，可以大量==节省内存==占用，==减少事件注册==，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li>
<li>可以实现当==新增子对象==时无需再次对其绑定</li>
</ul>
</li>
</ul>
<h3 id="5、Javascript如何实现继承？"><a href="#5、Javascript如何实现继承？" class="headerlink" title="5、Javascript如何实现继承？"></a>5、Javascript如何实现继承？</h3><ul>
<li>构造继承</li>
<li>原型继承</li>
<li>实例继承</li>
<li>拷贝继承</li>
<li>原型<code>prototype</code>机制或<code>apply</code>和<code>call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;wang&#x27;</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">this</span>.age = <span class="hljs-number">28</span>;<br>   &#125;<br>   Child.prototype = <span class="hljs-keyword">new</span> Parent();<span class="hljs-comment">//继承了Parent，通过原型</span><br><br>   <span class="hljs-keyword">var</span> demo = <span class="hljs-keyword">new</span> Child();<br>   alert(demo.age);<br>   alert(demo.name);<span class="hljs-comment">//得到被继承的属性</span><br> &#125;<br></code></pre></td></tr></table></figure>
<h3 id="6、谈谈This对象的理解"><a href="#6、谈谈This对象的理解" class="headerlink" title="6、谈谈This对象的理解"></a>6、谈谈This对象的理解</h3><ul>
<li><code>this</code>总是指向函数的==直接==调用者（而非间接调用者）</li>
<li>如果有<code>new</code>关键字，<code>this</code>指向==new==出来的那个对象</li>
<li>在==事件==中，<code>this</code>指向触发这个事件的<strong>对象</strong>，特殊的是，<code>IE</code>中的<strong>attachEvent</strong>中的<code>this</code>总是指向全局对象<code>Window</code></li>
</ul>
<h3 id="7、事件模型"><a href="#7、事件模型" class="headerlink" title="7、事件模型"></a>7、事件模型</h3><ul>
<li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>
<li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>
<li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>
<li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation（）</code>方法；在IE下设置<code>cancelBubble = true</code></li>
<li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault（）</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li>
</ul>
<h3 id="8、new操作符具体干了什么呢"><a href="#8、new操作符具体干了什么呢" class="headerlink" title="8、new操作符具体干了什么呢?"></a>8、new操作符具体干了什么呢?</h3><ul>
<li>创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型</li>
<li>属性和方法被加入到 <code>this</code> 引用的对象中</li>
<li>新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code></li>
</ul>
<h3 id="9、Ajax原理"><a href="#9、Ajax原理" class="headerlink" title="9、Ajax原理"></a>9、Ajax原理</h3><ul>
<li><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>
<li><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建连接</span><br>   <span class="hljs-keyword">var</span> xhr = <span class="hljs-literal">null</span>;<br>   xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>   <span class="hljs-comment">// 2. 连接服务器</span><br>   xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, url, <span class="hljs-literal">true</span>)<br>   <span class="hljs-comment">// 3. 发送请求</span><br>   xhr.send(<span class="hljs-literal">null</span>);<br>   <span class="hljs-comment">// 4. 接受请求</span><br>   xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-keyword">if</span>(xhr.readyState == <span class="hljs-number">4</span>)&#123;<br>           <span class="hljs-keyword">if</span>(xhr.status == <span class="hljs-number">200</span>)&#123;<br>               success(xhr.responseText);<br>           &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// fail</span><br>               fail &amp;&amp; fail(xhr.status);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h3 id="10、如何解决跨域问题"><a href="#10、如何解决跨域问题" class="headerlink" title="10、如何解决跨域问题?"></a>10、如何解决跨域问题?</h3><ul>
<li><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</li>
</ul>
<h3 id="11、模块化开发怎么做？"><a href="#11、模块化开发怎么做？" class="headerlink" title="11、模块化开发怎么做？"></a>11、模块化开发怎么做？</h3><ul>
<li>立即执行函数,不暴露私有成员</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>　　　　<span class="hljs-keyword">var</span> _count = <span class="hljs-number">0</span>;<br>　　　　<span class="hljs-keyword">var</span> m1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>　　　　　　<span class="hljs-comment">//...</span><br>　　　　&#125;;<br>　　　　<span class="hljs-keyword">var</span> m2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>　　　　　　<span class="hljs-comment">//...</span><br>　　　　&#125;;<br>　　　　<span class="hljs-keyword">return</span> &#123;<br>　　　　　　m1 : m1,<br>　　　　　　m2 : m2<br>　　　　&#125;;<br>　　&#125;)();<br></code></pre></td></tr></table></figure>
<h3 id="12、异步加载JS的方式有哪些？"><a href="#12、异步加载JS的方式有哪些？" class="headerlink" title="12、异步加载JS的方式有哪些？"></a>12、异步加载JS的方式有哪些？</h3><ul>
<li>defer，只支持<code>IE</code></li>
<li><code>async</code>：</li>
<li>创建<code>script</code>，插入到<code>DOM</code>中，加载完毕后<code>callBack</code></li>
</ul>
<h3 id="13、那些操作会造成内存泄漏？"><a href="#13、那些操作会造成内存泄漏？" class="headerlink" title="13、那些操作会造成内存泄漏？"></a>13、那些操作会造成内存泄漏？</h3><ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>闭包使用不当</li>
</ul>
<h3 id="14、XML和JSON的区别？"><a href="#14、XML和JSON的区别？" class="headerlink" title="14、XML和JSON的区别？"></a>14、XML和JSON的区别？</h3><ul>
<li>数据体积方面<ul>
<li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>
</ul>
</li>
<li>数据交互方面<ul>
<li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li>数据描述方面<ul>
<li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li>
</ul>
</li>
<li>传输速度方面<ul>
<li><code>JSON</code>的速度要远远快于<code>XML</code></li>
</ul>
</li>
</ul>
<h3 id="15、谈谈你对webpack的看法"><a href="#15、谈谈你对webpack的看法" class="headerlink" title="15、谈谈你对webpack的看法"></a>15、谈谈你对webpack的看法</h3><ul>
<li><code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包<code>Web</code>开发中所用到的<code>HTML</code>、<code>Javascript</code>、<code>CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源</li>
</ul>
<h3 id="16、说说你对AMD和Commonjs的理解"><a href="#16、说说你对AMD和Commonjs的理解" class="headerlink" title="16、说说你对AMD和Commonjs的理解"></a>16、说说你对AMD和Commonjs的理解</h3><ul>
<li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>
<li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>
</ul>
<h3 id="17、常见web安全及防护原理"><a href="#17、常见web安全及防护原理" class="headerlink" title="17、常见web安全及防护原理"></a>17、常见web安全及防护原理</h3><ul>
<li><code>sql</code>注入原理<ul>
<li>就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li>
</ul>
</li>
<li>总的来说有以下几点<ul>
<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li>
<li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>
<li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li>
</ul>
</li>
</ul>
<p><strong>XSS原理及防范</strong></p>
<ul>
<li><code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li>
</ul>
<p><strong>XSS防范方法</strong></p>
<ul>
<li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code>弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li>
</ul>
<p><strong>XSS与CSRF有什么区别吗？</strong></p>
<ul>
<li><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</li>
<li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li>
<li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li>
</ul>
<p><strong>CSRF的防御</strong></p>
<ul>
<li>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li>
<li>通过验证码的方法</li>
</ul>
<h3 id="18、用过哪些设计模式？"><a href="#18、用过哪些设计模式？" class="headerlink" title="18、用过哪些设计模式？"></a>18、用过哪些设计模式？</h3><ul>
<li>工厂模式：<ul>
<li>工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法</li>
<li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是<code>new</code>关键字</li>
</ul>
</li>
<li>构造函数模式<ul>
<li>使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>
<li>直接将属性和方法赋值给 <code>this</code>对象;</li>
</ul>
</li>
</ul>
<h3 id="19、为什么要有同源限制？"><a href="#19、为什么要有同源限制？" class="headerlink" title="19、为什么要有同源限制？"></a>19、为什么要有同源限制？</h3><ul>
<li>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>
<li>举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</li>
</ul>
<h3 id="20、offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#20、offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3><ul>
<li><code>offsetWidth/offsetHeight</code>返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li>
<li><code>clientWidth/clientHeight</code>返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li>
<li><code>scrollWidth/scrollHeight</code>返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li>
</ul>
<h3 id="21、javascript有哪些方法定义对象"><a href="#21、javascript有哪些方法定义对象" class="headerlink" title="21、javascript有哪些方法定义对象"></a>21、javascript有哪些方法定义对象</h3><ul>
<li>对象字面量： <code>var obj = &#123;&#125;;</code></li>
<li>构造函数： <code>var obj = new Object();</code></li>
<li>Object.create(): <code>var obj = Object.create(Object.prototype);</code></li>
</ul>
<h3 id="22、常见兼容性问题？"><a href="#22、常见兼容性问题？" class="headerlink" title="22、常见兼容性问题？"></a>22、常见兼容性问题？</h3><ul>
<li><code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></li>
<li>浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*&#123;margin:0;padding:0;&#125;</code>来统一,，但是全局效率很低，一般是如下这样解决：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">li</span>,<span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">dl</span>,<span class="hljs-selector-tag">dt</span>,<span class="hljs-selector-tag">dd</span>,<span class="hljs-selector-tag">form</span>,<span class="hljs-selector-tag">input</span>,<span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>,p&#123;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</li>
<li><code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</li>
</ul>
<h3 id="22、说说你对promise的了解"><a href="#22、说说你对promise的了解" class="headerlink" title="22、说说你对promise的了解"></a>22、说说你对promise的了解</h3><ul>
<li>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：<ul>
<li><code>pending:</code> 初始状态, 非 <code>fulfilled</code> 或 <code>rejected.</code></li>
<li><code>fulfilled:</code> 成功的操作.</li>
<li><code>rejected:</code> 失败的操作.</li>
<li><code>settled: Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li>
</ul>
</li>
<li>另外， <code>fulfilled</code>与 <code>rejected</code>一起合称 <code>settled</code></li>
<li><code>Promise</code> 对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code>) 计算</li>
</ul>
<p><strong>Promise 的构造函数</strong></p>
<ul>
<li>构造一个 <code>Promise</code>，最基本的用法如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (...) &#123;  <span class="hljs-comment">// succeed</span><br><br>            resolve(result);<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">// fails</span><br><br>            reject(<span class="hljs-built_in">Error</span>(errMessage));<br><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为<code>thenable</code>）。它的使用方法如下：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">promise.then(<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected)<br></code></pre></td></tr></table></figure></li>
<li><p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是 <code>future</code>，<code>onFulfilled</code> 对应<code>resolve</code>, <code>onRejected</code>对应 <code>reject</code></p>
</li>
</ul>
<h3 id="23、你觉得jQuery源码有哪些写的好的地方"><a href="#23、你觉得jQuery源码有哪些写的好的地方" class="headerlink" title="23、你觉得jQuery源码有哪些写的好的地方"></a>23、你觉得jQuery源码有哪些写的好的地方</h3><ul>
<li><code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li>
<li><code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li>
<li>有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li>
<li><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>
</ul>
<h3 id="24、vue、react、angular"><a href="#24、vue、react、angular" class="headerlink" title="24、vue、react、angular"></a>24、vue、react、angular</h3><ul>
<li><code>Vue.js</code><br>一个用于创建 <code>web</code> 交互界面的库，是一个精简的 <code>MVVM</code>。它通过双向数据绑定把 <code>View</code> 层和 <code>Model</code> 层连接了起来。实际的 <code>DOM</code> 封装和输出格式都被抽象为了<code>Directives</code> 和 <code>Filters</code></li>
<li><code>AngularJS</code><br>是一个比较完善的前端<code>MVVM</code>框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 <code>Angular</code>指令</li>
<li><code>react</code><br><code>React</code> 仅仅是 <code>VIEW</code> 层是<code>facebook</code>公司。推出的一个用于构建<code>UI</code>的一个库，能够实现服务器端的渲染。用了<code>virtual dom</code>，所以性能很好。</li>
</ul>
<h3 id="25、Node的应用场景"><a href="#25、Node的应用场景" class="headerlink" title="25、Node的应用场景"></a>25、Node的应用场景</h3><ul>
<li>特点：<ul>
<li>1、它是一个<code>Javascript</code>运行环境</li>
<li>2、依赖于<code>Chrome V8</code>引擎进行代码解释</li>
<li>3、事件驱动</li>
<li>4、非阻塞<code>I/O</code></li>
<li>5、单进程，单线程</li>
</ul>
</li>
<li>优点：<ul>
<li>高并发（最重要的优点）</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、只支持单<code>核CPU</code>，不能充分利用<code>CPU</code></li>
<li>2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>
</ul>
</li>
</ul>
<h3 id="26、谈谈你对AMD、CMD的理解"><a href="#26、谈谈你对AMD、CMD的理解" class="headerlink" title="26、谈谈你对AMD、CMD的理解"></a>26、谈谈你对AMD、CMD的理解</h3><ul>
<li><code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>
<li><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>
</ul>
<h3 id="27、那些操作会造成内存泄漏？"><a href="#27、那些操作会造成内存泄漏？" class="headerlink" title="27、那些操作会造成内存泄漏？"></a>27、那些操作会造成内存泄漏？</h3><ul>
<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
<li><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ul>
<h3 id="28、web开发中会话跟踪的方法有哪些"><a href="#28、web开发中会话跟踪的方法有哪些" class="headerlink" title="28、web开发中会话跟踪的方法有哪些"></a>28、web开发中会话跟踪的方法有哪些</h3><ul>
<li><code>cookie</code></li>
<li><code>session</code></li>
<li><code>url</code>重写</li>
<li>隐藏<code>input</code></li>
<li><code>ip</code>地址</li>
</ul>
<h3 id="29、介绍js的基本数据类型"><a href="#29、介绍js的基本数据类型" class="headerlink" title="29、介绍js的基本数据类型"></a>29、介绍js的基本数据类型</h3><ul>
<li><code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code></li>
</ul>
<h3 id="30、介绍js有哪些内置对象？"><a href="#30、介绍js有哪些内置对象？" class="headerlink" title="30、介绍js有哪些内置对象？"></a>30、介绍js有哪些内置对象？</h3><ul>
<li><code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li>
<li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code></li>
<li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>
</ul>
<h3 id="31、说几条写JavaScript的基本规范？"><a href="#31、说几条写JavaScript的基本规范？" class="headerlink" title="31、说几条写JavaScript的基本规范？"></a>31、说几条写JavaScript的基本规范？</h3><ul>
<li>不要在同一行声明多个变量</li>
<li>请使用<code>===/!==</code>来比较<code>true/false</code>或者数值</li>
<li>使用对象字面量替代<code>new Array</code>这种形式</li>
<li>不要使用全局函数</li>
<li><code>Switch</code>语句必须带有<code>default</code>分支</li>
<li><code>If</code>语句必须使用大括号</li>
<li><code>for-in</code>循环中的变量 应该使用<code>var</code>关键字明确限定作用域，从而避免作用域污</li>
</ul>
<h3 id="32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h3><ul>
<li>栈：原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Numbe</code>r、<code>String</code>）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
<li>两种类型的区别是：存储位置不同；</li>
<li>原始数据类型直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆(<code>heap</code>)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</li>
<li>在栈中的地址，取得地址后从堆中获得实体</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94ul2g9eej30cq0c0glw.jpg" srcset="/img/loading.gif" alt="image-20191120215601694"></p>
<h3 id="33、javascript创建对象的几种方式？"><a href="#33、javascript创建对象的几种方式？" class="headerlink" title="33、javascript创建对象的几种方式？"></a>33、javascript创建对象的几种方式？</h3><blockquote>
<p><code>javascript</code>创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用<code>JSON</code>；但写法有很多种，也能混合使用</p>
</blockquote>
<ul>
<li>对象字面量的方式</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">person=&#123;<span class="hljs-attr">firstname:</span><span class="hljs-string">&quot;Mark&quot;</span>,<span class="hljs-attr">lastname:</span><span class="hljs-string">&quot;Yun&quot;</span>,<span class="hljs-attr">age:</span><span class="hljs-number">25</span>,<span class="hljs-attr">eyecolor:</span><span class="hljs-string">&quot;black&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>用<code>function</code>来模拟无参的构造函数</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-keyword">function</span> Person()&#123;&#125;<br>    var person=<span class="hljs-built_in">new</span> Person();//定义一个<span class="hljs-keyword">function</span>，如果使用<span class="hljs-built_in">new</span>&quot;实例化&quot;,该<span class="hljs-keyword">function</span>可以看作是一个<span class="hljs-keyword">Class</span><br>        person.name=&quot;Mark&quot;;<br>        person.age=&quot;25&quot;;<br>        person.<span class="hljs-keyword">work</span>=<span class="hljs-keyword">function</span>()&#123;<br>        alert(person.name+&quot; hello...&quot;);<br>    &#125;<br>person.<span class="hljs-keyword">work</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>用<code>function</code>来模拟参构造函数来实现（用<code>this</code>关键字定义构造的上下文属性）</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pet</span><span class="hljs-params">(name,age,hobby)</span></span>&#123;<br>       <span class="hljs-keyword">this</span>.name=name;<span class="hljs-comment">//this作用域：当前对象</span><br>       <span class="hljs-keyword">this</span>.age=age;<br>       <span class="hljs-keyword">this</span>.hobby=hobby;<br>       <span class="hljs-keyword">this</span>.eat=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>          alert(<span class="hljs-string">&quot;我叫&quot;</span>+<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;,我喜欢&quot;</span>+<span class="hljs-keyword">this</span>.hobby+<span class="hljs-string">&quot;,是个程序员&quot;</span>);<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> maidou =<span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;麦兜&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-string">&quot;coding&quot;</span>);<span class="hljs-comment">//实例化、创建对象</span><br>    maidou.eat();<span class="hljs-comment">//调用eat方法</span><br></code></pre></td></tr></table></figure>
<ul>
<li>用工厂方式来创建（内置对象）</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var wcDog =<span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>();<br>     wcDog.name=&quot;旺财&quot;;<br>     wcDog.age=<span class="hljs-number">3</span>;<br>     wcDog.<span class="hljs-keyword">work</span>=<span class="hljs-keyword">function</span>()&#123;<br>       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);<br>     &#125;<br>     wcDog.<span class="hljs-keyword">work</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>用原型方式来创建</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span><span class="hljs-params">()</span></span>&#123;<br><br>     &#125;<br>     Dog.prototype.name=<span class="hljs-string">&quot;旺财&quot;</span>;<br>     Dog.prototype.eat=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>     alert(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;是个吃货&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">var</span> wangcai =<span class="hljs-keyword">new</span> Dog();<br>     wangcai.eat();<br></code></pre></td></tr></table></figure>
<ul>
<li>用混合方式来创建</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span><span class="hljs-params">(name,price)</span></span>&#123;<br>     <span class="hljs-keyword">this</span>.name=name;<br>     <span class="hljs-keyword">this</span>.price=price; <br>   &#125;<br>    Car.prototype.sell=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>      alert(<span class="hljs-string">&quot;我是&quot;</span>+<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;，我现在卖&quot;</span>+<span class="hljs-keyword">this</span>.price+<span class="hljs-string">&quot;万元&quot;</span>);<br>     &#125;<br>   <span class="hljs-keyword">var</span> camry =<span class="hljs-keyword">new</span> Car(<span class="hljs-string">&quot;凯美瑞&quot;</span>,<span class="hljs-number">27</span>);<br>   camry.sell();<br></code></pre></td></tr></table></figure>
<h3 id="34、eval是做什么的？"><a href="#34、eval是做什么的？" class="headerlink" title="34、eval是做什么的？"></a>34、eval是做什么的？</h3><ul>
<li>它的功能是把对应的字符串解析成<code>JS</code>代码并运行</li>
<li>应该避免使用<code>eval</code>，不安全，非常耗性能（<code>2</code>次，一次解析成<code>js</code>语句，一次执行）</li>
<li>由<code>JSON</code>字符串转换为JSON对象的时候可以用<code>eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;)</code></li>
</ul>
<h3 id="35、null，undefined-的区别？"><a href="#35、null，undefined-的区别？" class="headerlink" title="35、null，undefined 的区别？"></a>35、null，undefined 的区别？</h3><ul>
<li><code>undefined</code> 表示不存在这个值。</li>
<li><code>undefined</code> :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></li>
<li>例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li>
<li><code>null</code> 表示一个对象被定义了，值为“空值”</li>
<li><code>null</code> : 是一个对象(空对象, 没有任何属性和方法)</li>
<li>例如作为函数的参数，表示该函数的参数不是对象；</li>
<li>在验证<code>null</code>时，一定要使用　<code>===</code> ，因为 <code>==</code>无法分别<code>null</code> 和　<code>undefined</code></li>
</ul>
<h3 id="36、-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#36、-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="36、[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>36、[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><ul>
<li><code>[1, NaN, NaN]</code>因为 <code>parseInt</code> 需要两个参数 <code>(val, radix)</code>，其中<code>radix</code> 表示解析时用的基数。</li>
<li><code>map</code>传了 <code>3</code>个<code>(element, index, array)</code>，对应的 <code>radix</code> 不合法导致解析失败。</li>
</ul>
<h3 id="37、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#37、javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h3><ul>
<li><code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>
</ul>
<h3 id="38、JSON-的了解？"><a href="#38、JSON-的了解？" class="headerlink" title="38、JSON 的了解？**"></a>38、JSON 的了解？**</h3><ul>
<li><code>JSON(JavaScript Object Notation)</code> 是一种轻量级的数据交换格式</li>
<li>它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li>
<li><code>JSON</code>字符串转换为JSON对象:</li>
</ul>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> obj =eval(<span class="hljs-string">&#x27;(&#x27;</span>+ <span class="hljs-built_in">str</span> +<span class="hljs-string">&#x27;)&#x27;</span>);<br><span class="hljs-built_in">var</span> obj = <span class="hljs-built_in">str</span>.parseJSON();<br><span class="hljs-built_in">var</span> obj = JSON.parse(<span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>JSON</code>对象转换为JSON字符串：</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">last</span>=obj.toJSONString();<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">last</span>=JSON.stringify(obj);<br></code></pre></td></tr></table></figure>
<h3 id="39、js延迟加载的方式有哪些？"><a href="#39、js延迟加载的方式有哪些？" class="headerlink" title="39、js延迟加载的方式有哪些？"></a>39、js延迟加载的方式有哪些？</h3><ul>
<li><code>defer</code>和<code>async</code>、动态创建<code>DOM</code>方式（用得最多）、按需异步载入<code>js</code></li>
</ul>
<h3 id="40、同步和异步的区别"><a href="#40、同步和异步的区别" class="headerlink" title="40、同步和异步的区别?"></a>40、同步和异步的区别?</h3><ul>
<li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
</ul>
<h3 id="41、渐进增强和优雅降级"><a href="#41、渐进增强和优雅降级" class="headerlink" title="41、渐进增强和优雅降级"></a>41、渐进增强和优雅降级</h3><ul>
<li>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>
<li>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li>
</ul>
<h3 id="42、defer和async"><a href="#42、defer和async" class="headerlink" title="42、defer和async"></a>42、defer和async</h3><ul>
<li><code>defer</code>并行加载<code>js</code>文件，会按照页面上<code>script</code>标签的顺序执行</li>
<li><code>async</code>并行加载<code>js</code>文件，下载完成立即执行，不会按照页面上<code>script</code>标签的顺序执行</li>
</ul>
<h3 id="43、说说严格模式的限制"><a href="#43、说说严格模式的限制" class="headerlink" title="43、说说严格模式的限制"></a>43、说说严格模式的限制</h3><ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>禁止<code>this</code>指向全局对象</li>
</ul>
<h3 id="44、attribute和property的区别是什么？"><a href="#44、attribute和property的区别是什么？" class="headerlink" title="44、attribute和property的区别是什么？"></a>44、attribute和property的区别是什么？</h3><ul>
<li><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</li>
<li><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</li>
<li>对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的</li>
<li>但是对于自定义的属性来说，他们是不同步的</li>
</ul>
<h3 id="45、谈谈你对ES6的理解"><a href="#45、谈谈你对ES6的理解" class="headerlink" title="45、谈谈你对ES6的理解"></a>45、谈谈你对ES6的理解</h3><ul>
<li>新增模板字符串（为<code>JavaScript</code>提供了简单的字符串插值功能）</li>
<li>箭头函数</li>
<li><code>for-of</code>（用来遍历数据—例如数组中的值。）</li>
<li><code>arguments</code>对象可被不定参数和默认参数完美代替。</li>
<li><code>ES6</code>将p<code>romise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。</li>
<li>增加了<code>let</code>和<code>const</code>命令，用来声明变量。</li>
<li>增加了块级作用域。</li>
<li><code>let</code>命令实际上就增加了块级作用域。</li>
<li>还有就是引入<code>module</code>模块的概念</li>
</ul>
<h1 id="4-编程题"><a href="#4-编程题" class="headerlink" title="4.编程题"></a>4.编程题</h1><h3 id="1、写一个通用的事件侦听器函数"><a href="#1、写一个通用的事件侦听器函数" class="headerlink" title="1、写一个通用的事件侦听器函数"></a>1、写一个通用的事件侦听器函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// event(事件)工具集，来源：github.com/markyun</span><br>   markyun.Event = &#123;<br><br>       <span class="hljs-comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br>       <span class="hljs-comment">// 参数： 操作的元素,事件名称 ,事件处理程序</span><br>       addEvent : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (element.addEventListener) &#123;<br>               <span class="hljs-comment">//事件类型、需要执行的函数、是否捕捉</span><br>               element.addEventListener(type, handler, <span class="hljs-literal">false</span>);<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.attachEvent) &#123;<br>               element.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + type, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   handler.call(element);<br>               &#125;);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               element[<span class="hljs-string">&#x27;on&#x27;</span> + type] = handler;<br>           &#125;<br>       &#125;,<br>       <span class="hljs-comment">// 移除事件</span><br>       removeEvent : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (element.removeEventListener) &#123;<br>               element.removeEventListener(type, handler, <span class="hljs-literal">false</span>);<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.datachEvent) &#123;<br>               element.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + type, handler);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               element[<span class="hljs-string">&#x27;on&#x27;</span> + type] = <span class="hljs-literal">null</span>;<br>           &#125;<br>       &#125;,<br>       <span class="hljs-comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)</span><br>       stopPropagation : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (ev.stopPropagation) &#123;<br>               ev.stopPropagation();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               ev.cancelBubble = <span class="hljs-literal">true</span>;<br>           &#125;<br>       &#125;,<br>       <span class="hljs-comment">// 取消事件的默认行为</span><br>       preventDefault : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>           <span class="hljs-keyword">if</span> (event.preventDefault) &#123;<br>               event.preventDefault();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               event.returnValue = <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;,<br>       <span class="hljs-comment">// 获取事件目标</span><br>       getTarget : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>           <span class="hljs-keyword">return</span> event.target || event.srcElement;<br>       &#125;<br></code></pre></td></tr></table></figure>
<h3 id="2、判断数组还是对象"><a href="#2、判断数组还是对象" class="headerlink" title="2、判断数组还是对象"></a>2、判断数组还是对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(arg) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Array&quot;</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Object</span>.prototype.toString.call(arg) === <span class="hljs-string">&#x27;[object Object]&#x27;</span>)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Object&quot;</span>;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h3><ul>
<li>每次比较相邻的两个数，如果后一个比前一个小，换位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) &#123;<br>            <span class="hljs-keyword">var</span> temp;<br>            temp = arr[j];<br>            arr[j] = arr[j + <span class="hljs-number">1</span>];<br>            arr[j + <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(bubbleSort(arr));<br></code></pre></td></tr></table></figure>
<h3 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h3><ul>
<li>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> [];    <span class="hljs-comment">// 返回空数组</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> cIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">var</span> c = arr.splice(cIndex, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">var</span> l = [];<br>    <span class="hljs-keyword">var</span> r = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; c) &#123;<br>            l.push(arr[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.push(arr[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> quickSort(l).concat(c, quickSort(r));<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(quickSort(arr));<br></code></pre></td></tr></table></figure>
<h3 id="5、编写一个方法-求一个字符串的字节长度"><a href="#5、编写一个方法-求一个字符串的字节长度" class="headerlink" title="5、编写一个方法 求一个字符串的字节长度"></a>5、编写一个方法 求一个字符串的字节长度</h3><ul>
<li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetBytes</span>(<span class="hljs-params">str</span>)</span>&#123;<br><br>        <span class="hljs-keyword">var</span> len = str.length;<br><br>        <span class="hljs-keyword">var</span> bytes = len;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br><br>            <span class="hljs-keyword">if</span> (str.charCodeAt(i) &gt; <span class="hljs-number">255</span>) bytes++;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> bytes;<br><br>    &#125;<br><br>alert(GetBytes(<span class="hljs-string">&quot;你好,as&quot;</span>));<br></code></pre></td></tr></table></figure>
<h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h1><h3 id="1、谈谈你对重构的理解"><a href="#1、谈谈你对重构的理解" class="headerlink" title="1、谈谈你对重构的理解"></a>1、谈谈你对重构的理解</h3><ul>
<li>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI</li>
<li>对于传统的网站来说重构通常是：<ul>
<li>表格(<code>table</code>)布局改为<code>DIV+CSS</code></li>
<li>使网站前端兼容于现代浏览器(针对于不合规范的<code>CSS</code>、如对IE6有效的)</li>
<li>对于移动平台的优化</li>
<li>针对于<code>SEO</code>进行优化</li>
</ul>
</li>
</ul>
<h3 id="2、什么样的前端代码是好的"><a href="#2、什么样的前端代码是好的" class="headerlink" title="2、什么样的前端代码是好的"></a>2、什么样的前端代码是好的</h3><ul>
<li>高复用低耦合，这样文件小，好维护，而且好扩展。</li>
</ul>
<h3 id="3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><ul>
<li>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近<ul>
<li>实现界面交互</li>
<li>提升用户体验</li>
<li>有了Node.js，前端可以实现服务端的一些事情</li>
</ul>
</li>
<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，</li>
</ul>
<ul>
<li>与团队成员，<code>UI</code>设计，产品经理的沟通；</li>
<li>做好的页面结构，页面重构和用户体验；</li>
</ul>
<h3 id="4、你觉得前端工程的价值体现在哪"><a href="#4、你觉得前端工程的价值体现在哪" class="headerlink" title="4、你觉得前端工程的价值体现在哪"></a>4、你觉得前端工程的价值体现在哪</h3><ul>
<li>为简化用户使用提供技术支持（交互部分）</li>
<li>为多个浏览器兼容性提供支持</li>
<li>为提高用户浏览速度（浏览器性能）提供支持</li>
<li>为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持</li>
<li>为展示数据提供支持（数据接口）</li>
</ul>
<h3 id="5、平时如何管理你的项目？"><a href="#5、平时如何管理你的项目？" class="headerlink" title="5、平时如何管理你的项目？"></a>5、平时如何管理你的项目？</h3><ul>
<li>先期团队必须确定好全局样式（<code>globe.css</code>），编码模式(<code>utf-8</code>) 等；</li>
<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>
<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>
<li>页面进行标注（例如 页面 模块 开始和结束）；</li>
<li><code>CSS</code>跟<code>HTML</code> 分文件夹并行存放，命名都得统一（例如<code>style.css</code>）；</li>
<li><code>JS</code> 分文件夹存放 命名以该<code>JS</code>功能为准的英文翻译。</li>
<li>图片采用整合的 <code>images.png png8</code> 格式文件使用 - 尽量整合在一起使用方便将来的管理</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="6、7答案（省略）"><a href="#6、7答案（省略）" class="headerlink" title="6、7答案（省略）"></a>6、7答案（省略）</h2><h3 id="6-一些问题"><a href="#6-一些问题" class="headerlink" title="6.一些问题"></a>6.一些问题</h3><ul>
<li>你的项目中技术难点是什么？</li>
<li>遇到了什么问题？</li>
<li>你是怎么解决的？c</li>
<li>最近在看哪些前端方面的书？</li>
<li>平时是如何学习前端开发的？</li>
<li>为什么大型应用需要从多个域名请求资源？</li>
<li>什么样的页面具有良好的用户体验 </li>
<li>是否了解<code>Web</code>注入攻击，说下原理，最- 常见的两种攻击（<code>XSS</code> 和 <code>CSRF</code>）了解到什么程度</li>
</ul>
<h3 id="7-人事面"><a href="#7-人事面" class="headerlink" title="7.人事面"></a>7.人事面</h3><ul>
<li>面试完你还有什么问题要问的吗</li>
<li>你有什么爱好?</li>
<li>你最大的优点和缺点是什么?</li>
<li>你为什么会选择这个行业，职位?</li>
<li>你觉得你适合从事这个岗位吗?</li>
<li>你有什么职业规划?</li>
<li>你对工资有什么要求?</li>
<li>如何看待前端开发？</li>
<li>未来三到五年的规划是怎样的？ </li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/web%E9%9D%A2%E8%AF%95%E9%A2%98/">web面试题</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/16/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">
                        <span class="hidden-mobile">我的第一篇博客文章</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="###"><span>Srendipity 小确幸</span><img alt="幸运草图片🍀" src="/img/clover3.png" srcset="/img/loading.gif" style="width:20px;height:20px;margin: 0 5px 5px;"></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        苏ICP备20017214号
      </a>
    </span>
    
  </div>


  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
